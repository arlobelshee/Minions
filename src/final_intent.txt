Fools is a language for defining languages. That's all it is.

Minions is a language writen in that language. It extends Fools, so it is also a language for
defining languages. However, it is a full general-purpose language that speaks multiple
paradigms.

Both languages can be interpreted or compiled to any of several back-ends.

The bootstrap sequence for a platform is to write a Fools interpreter for that platform and
a Fools model code generator that targets that platform. This might also include implementing
a platform bindings library (to give uniform OO access to platform specifics). Once these are
written, you can then interpret Fools in Fools and code-gen a Fools compiler. Then you can
use that compiler to do Minions subsets and make whatever Minions compiler starting points you
want.

Each project can choose to make its own Minions language. Common creoles will emerge around
paradigms that people find useful. In any case, a library can be written in a completely different
variation from the code that uses it. Heck, a block can be written in a different language
from the blocks that contain it or that it contains.

The only thing that is consistent from language to language is the underlying execution model:
continuations instead of stack-based functions with loose coupling as to order of execution,
all data held in partially or fully isolated universes, Minions (actor pattern) that send messages
to each other but are otherwise independent, and the runtime controls all aspects of threading.

This execution model has two important characteristics:
 * It is highly decoupled.
 * The model only states constraints; the runtime optimizes within those constraints and chooses
 what will actually execute when.

Fools features:
 * Can parse a block comprehension. Can then use that comprehension to parse another block.
 * Can parse a function declaration and add that to the execution model.
 * Can emit an execution model to some backend.
 * Can run an execution model (be a Fools interpreter).
 * Cannot understand infix expressions (no operators in the language).
 * Can understand string, integer and code literals (no floats nor any other type).
 * Can parse a structure definition (UDT) and add that to the execution model.
 * Can parse an assignment and add that to the exeuction model.
 * Can call compile-time function definitions.
 * Can decide when to create a Fool and call spawn.minion() at the correct time.
 * 

Key concepts and when they're applicable
----------------------------------------

+------------------+-------------+-------------------------------------------------------------------+
|     Concept      |    When     |                        Meaning                                    |
+------------------+-------------+-------------------------------------------------------------------+
| Minion           | run time    | A particular actor instance. Listens for messages and follows     |
|                  |             | instructions to process those messages. May send more messages.   |
+------------------+-------------+-------------------------------------------------------------------+
| Function         | static      | A declaration of a set of instructions that can be executed.      |
+------------------+-------------+-------------------------------------------------------------------+
| Continuation     | run time    | All function calls are made as continuations. There is a linked   |
| (Frame)          |             | list of frames, rather than an array of frames. It is singly-     |
|                  |             | linked. Multiple frames may point back to the same "caller."      |
+------------------+-------------+-------------------------------------------------------------------+
| Type Class       | static      | A type restriction. States that a particular function will accept |
|                  |             | only a subset of all possible types for a particular arg. Defines |
|                  |             | what this function expects to see on that arg.                    |
+------------------+-------------+-------------------------------------------------------------------+
| Class            | static      | A user-defined type. Consists of member data and functions. Can   |
|                  |             | be used to satisfy one or more type classes. Every class          |
|                  |             | introduces at least one type class.                               |
+------------------+-------------+-------------------------------------------------------------------+
| Message          | run time    | A very simple data-only UDT that can be sent to a Minion directly |
|                  |             | or via broadcast.                                                 |
+------------------+-------------+-------------------------------------------------------------------+
| Pattern Match    | static      | Declares actions to take when partiuclar messages arrive.         |
+------------------+-------------+-------------------------------------------------------------------+
|                  |             |                                                                   |
+------------------+-------------+-------------------------------------------------------------------+
|                  |             |                                                                   |
+------------------+-------------+-------------------------------------------------------------------+
|                  |             |                                                                   |
+------------------+-------------+-------------------------------------------------------------------+
|                  |             |                                                                   |
+------------------+-------------+-------------------------------------------------------------------+


On Laziness
-----------

If you explictly curry a call, then you get the behavior you expect. Pass that to another Minion and
it will still be delated & executed in that Minion's context (continuation stack).

But all values are also lazy. Pass one around and it will delay evaluation as long as possible. The
following all require evaluation:
 * Being used in another evaluated context.
 * Explicit evaluation (a call of the evaluate method).
 * Being passed in an eager-typed variable (argument, return, or local).
 * Being passed to another minion [unless we can pass an uneval & then evaluate it back in this
 minion's context if the other minion decides to use it].

In all cases, lazy values will evaluate a maximum of one time. Lazies cannot be shared between minions,
so are guaranteed to evaluate without threading concerns. The only things that can be shared are
fully-evaluated values and explict futures (tell me if you need the value, then I'll evaluate it and
give you the evaluated value).

The closure nature of these explicit futures can probably be hidden from the language level.



The low-level execution model doesn't need most of the language constructs. It doesn't need type safety (already checked). It doesn't need functions, really - just instruction sequences & a global symbol table. Function refs should probably be symbolic, even though that causes perf penalties. Intern all those strings and we're good enough - back to pointer comparisons at that point. We can probably just use the default function implementation of the underlying platform. We transform a minions function and its continuation-based all into a function that takes args: frame instance, args instance (flyweight the void case), returns instance (same flyweight), and perhaps a global symbol table (perhaps can do without). Transform all minions calls into appropriate calls to these functions. Crazy enough that it just might work - and with good perf if it does. The function may also need to take or return something that allows me to do CPS. I'd like to handle full co-routines, so need to have the data to allow the function to effectively yield and resume (though that could be managed by compiling such a function into multiple functions and dispatching between them as needed).

